"""This script is used to generate SLURM scripts for running compute jobs on the department servers.
The script takes in a number of arguments that are used to generate the SLURM script. The script
can be run from the command line and the generated SLURM script can be submitted to the SLURM
scheduler using the `sbatch` command.
"""

import argparse
import logging
import os
import re
import sys
from typing import Any

# The following is an example of the SLURM script that is generated by this script
# """
# #!/bin/bash
# #
# #SBATCH --job-name=example-cpu # Job name for tracking
# #SBATCH --partition=cpu-batch  # Partition you wish to use (see above for list)
# #SBATCH --cpus-per-task=1      # Number of CPU threads used by your job, set this upto 40 as required.
# #SBATCH --mem-per-cpu=1500     # RAM in MB needed per core (i.e. 1500MB * 40 threads = 60GB RAM)
# #SBATCH --time=2-00:00:00      # Job time limit set to 2 days (48 hours)
# #
# #SBATCH --mail-type=END,FAIL,TIME_LIMIT_80 # Events to send email on, remove if you don't want this
# #SBATCH --output=joboutput_%j.out # Standard out from your job
# #SBATCH --error=joboutput_%j.err  # Standard error from your job

# ## Initialisation ##
# source /etc/profile.d/modules.sh
# source /etc/profile.d/conda.sh

# ## Execute your program(s) ##
# python3 -c "print('hello')"
# """

####################################################################################################
# Local functions and Variables
####################################################################################################
LOGGER = logging.getLogger(__name__)


class GenerateSlurmScript:
    batch_script_name: str = ''
    batch_script_path: str = ''
    initialisation_commands: list[str] = []
    execution_commands: list[str] = []
    update: bool = False
    job_name: str = ''
    partition: str = ''
    ntasks: int = None
    cpus_per_task: int = 0
    mem_per_cpu: int = None
    mem: int = None
    exclusive: str = ''
    time: int = None
    mail_type: list[str] = None
    mail_user: str = ''
    output: str = ''
    error: str = ''
    input: str = ''
    gres: str = ''
    begin: str = ''
    chdir: str = ''
    export: str = ''
    get_user_env: bool = False
    test_only: bool = False
    wait: bool = False
    wait_all_nodes: bool = False
    slurm_verbose: bool = False

    def __init__(self,
        **kwargs,
    ) -> None:
        for key, value in kwargs.items():
            setattr(self, key, value)
        LOGGER.debug("Slurm generation script initialised successfully.")

    def __str__(self) -> str:
        return_string = f"""
        batch_script_name: {self.batch_script_name}
        script_path: {self.batch_script_path}
        initialisation_commands: {self.initialisation_commands}
        execution_commands: {self.execution_commands}
        job_name: {self.job_name}
        partition: {self.partition}
        ntasks: {self.ntasks}
        cpus_per_task: {self.cpus_per_task}
        mem_per_cpu: {self.mem_per_cpu}
        mem: {self.mem}
        exclusive: {self.exclusive}
        time: {self.time}
        mail_type: {self.mail_type}
        mail_user: {self.mail_user}
        output: {self.output}
        error: {self.error}
        input: {self.input}
        gres: {self.gres}
        begin: {self.begin}
        chdir: {self.chdir}
        export: {self.export}
        get_user_env: {self.get_user_env}
        test_only: {self.test_only}
        wait: {self.wait}
        wait_all_nodes: {self.wait_all_nodes}
        slurm_verbose: {self.slurm_verbose}
    """
        return return_string


    def validate_args(self) -> int:
        """This function validates the arguments passed to the script. It will check that the arguments are
        compatible with the SLURM configuration for the department servers. More information on the compatibility
        can be found at https://warwick.ac.uk/fac/sci/dcs/intranet/user_guide/batch_compute. The other restrictions
        are based on SBATCH itself only with additional restrictions we have added.

        Args:
            args (argparse.Namespace): The arguments passed to the script.

        Raises:
            ValueError: If the partition is not recognised.
            AssertionError: If any of the arguments are invalid.

        Returns:
            0 if the arguments checks are valid
        """
        assert (
            self.ntasks is None or self.ntasks >= 1
        ), "ntasks must be greater than or equal to 1 if provided."
        assert self.cpus_per_task >= 1, "cpus_per_task must be greater than or equal to 1."
        assert (
            1 <= self.time <= 2880
        ), "time must be between 1 and 2880 minutes. (This is up to 48 hours)"
        # Make sure that only mem or mem_per_cpu is provided
        assert (
            self.mem is None or self.mem_per_cpu is None
        ), "Only one of mem or mem_per_cpu can be provided."
        assert (
            self.mail_type is None or len(self.mail_type) <= 3
        ), "mail_type can have a maximum of 3 values."
        assert (
            not self.mail_user or "@" in self.mail_user
        ), "mail_user must be a valid email address."
        assert not self.output or self.output.endswith(
            ".out"
        ), "output path must end with '.out'."
        assert not self.error or self.error.endswith(
            ".err"
        ), "error path must end with '.err'."
        assert not self.input or os.path.exists(
            self.input
        ), "input path must be a valid file path."
        assert not self.gres or self.gres.startswith(
            "gpu:"
        ), "gres must follow the format 'gpu:<number>'."
        assert (
            not self.begin
            or re.match(r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}", self.begin)
            or re.match(r"\d+", self.begin)
        ), "begin must be in the format 'YYYY-MM-DDTHH:MM:SS'. or a number of minutes to delay by."
        # Check that the script is able to access the path to the output and error files
        assert os.access(
            self.batch_script_path, os.W_OK
        ), "The batch script path is not writable."
        if f"{os.sep}" in self.output:
            assert os.access(
                os.path.split(self.output)[0], os.W_OK
            ), (
                "The output path is not writable."
            )
        if f"{os.sep}" in self.error:
            assert os.access(
                os.path.split(self.error)[0], os.W_OK
            ), (
                "The error path is not writable."
            )
        assert not self.chdir or os.access(
            self.chdir, os.R_OK
        ), "The chdir path is not executable."
        assert not self.input or os.access(
            self.input, os.R_OK
        ), "The input path is not readable."
        # Partition specific checks
        match self.partition:
            case "cpu-batch":
                assert (
                    self.cpus_per_task <= 200
                ), "cpus_per_task must be less than or equal to 200 for the cpu-batch partition."
                assert (
                    self.mem_per_cpu is None or 1 <= self.mem_per_cpu <= 3000
                ), "mem_per_cpu must be between 1 and 3000MB for the cpu-batch partition."
                assert (
                    self.mem is None or 1 <= self.mem <= 60000
                ), "mem must be between 1 and 60000MB for the cpu-batch partition."
            case "parrot":
                assert (
                    self.cpus_per_task <= 40
                ), "cpus_per_task must be less than or equal to 40 for the parrot partition."
                assert (
                    self.mem_per_cpu is None or 1 <= self.mem_per_cpu <= 10000
                ), "mem_per_cpu must be between 1 and 10000MB for the parrot partition."
                assert (
                    self.mem is None or 1 <= self.mem <= 120000
                ), "mem must be between 1 and 120000MB for the parrot partition."
            case "eagle":
                assert (
                    self.cpus_per_task <= 6
                ), "cpus_per_task must be less than or equal to 6 for the eagle partition."
                assert (
                    self.mem_per_cpu is None or 1 <= self.mem_per_cpu <= 10000
                ), "mem_per_cpu must be between 1 and 10000 MBfor the eagle partition."
                assert (
                    self.mem is None or 1 <= self.mem <= 60000
                ), "mem must be between 1 and 60000MB for the eagle partition."
            case "gecko":
                assert (
                    self.cpus_per_task <= 96
                ), "cpus_per_task must be less than or equal to 96 for the gecko partition."
                assert (
                    self.mem_per_cpu is None or 1 <= self.mem_per_cpu <= 5000
                ), "mem_per_cpu must be between 1 and 5000MB for the gecko partition."
                assert (
                    self.mem is None or 1 <= self.mem <= 480000
                ), "mem must be between 1 and 480000MB for the gecko partition."
            case "falcon":
                assert (
                    self.cpus_per_task <= 12
                ), "cpus_per_task must be less than or equal to 12 for the falcon partition."
                assert (
                    self.mem_per_cpu is None or 1 <= self.mem_per_cpu <= 5000
                ), "mem_per_cpu must be between 1 and 5000MB for the falcon partition."
                assert (
                    self.mem is None or 1 <= self.mem <= 60000
                ), "mem must be between 1 and 60000MB for the falcon partition."
            case "falcon-debug":
                assert (
                    self.cpus_per_task <= 12
                ), "cpus_per_task must be less than or equal to 12 for the falcon-debug partition."
                assert (
                    self.mem_per_cpu is None or 1 <= self.mem_per_cpu <= 5000
                ), "mem_per_cpu must be between 1 and 5000MB for the falcon-debug partition."
                assert (
                    self.mem is None or 1 <= self.mem <= 60000
                ), "mem must be between 1 and 60000MB for the falcon-debug partition."
                assert (
                    self.time <= 30
                ), "time must be less than or equal to 30 minutes for the falcon-debug partition."
            case "eagle-debug":
                assert (
                    self.cpus_per_task <= 6
                ), "cpus_per_task must be less than or equal to 6 for the eagle-debug partition."
                assert (
                    self.mem_per_cpu is None or 1 <= self.mem_per_cpu <= 10000
                ), "mem_per_cpu must be between 1 and 10000MB for the eagle-debug partition."
                assert (
                    self.mem is None or 1 <= self.mem <= 60000
                ), "mem must be between 1 and 60000MB for the eagle-debug partition."
                assert (
                    self.time <= 30
                ), "time must be less than or equal to 30 minutes for the eagle-debug partition."
            case _:
                raise ValueError("Partition not recognised.")
        LOGGER.debug("Arguments validated successfully.")
        return 0


    def generate_slurm_script(
        self, formatted_slurm_args: dict[str, Any]
    ) -> int:
        """This function generates the SLURM script based on the arguments passed to the script. It will
        follow a SLURM script template whilst adding the additional SBATCH arguments that have been passed
        to the script. Finally, it will add the initialisation and execution commands to the script before
        writing it to the specified path.

        Args:
            args argparse.Namespace: The arguments passed to the script.
            formatted_slurm_args dict: The formatted SLURM arguments.

        Returns:
            0 if the SLURM script was generated successfully.
        """
        full_path = os.path.join(self.batch_script_path, f"{self.batch_script_name}.sbatch")
        full_path = re.sub(r" ", "_", full_path) # Replace spaces with underscores
        script_string = []
        script_string.append("#!/bin/bash")
        script_string.append("#")
        for key, value in formatted_slurm_args.items():
            # For some of the value types they need to be formatted correctly
            if isinstance(value, list):
                value = ",".join(value)
                script_string.append(f"#SBATCH {key}={value}")
            elif isinstance(value, bool):
                script_string.append(f"#SBATCH {key}")
            else:
                script_string.append(f"#SBATCH {key}={value}")
        script_string.append("#")
        script_string.append("# Initialisation")
        for command in self.initialisation_commands:
            script_string.append(command)
        script_string.append("#")
        script_string.append("# Execute your program(s)")
        for command in self.execution_commands:
            script_string.append(command)
        script_string.append("#")
        # We are using the overwrite flag to determine if we should overwrite the file or not
        if self.update:
            with open(full_path, "w", encoding="utf-8") as f:
                f.write("\n".join(script_string))
                LOGGER.info("SLURM script generated at %s", full_path)
                return 0
        if os.path.exists(full_path):
            LOGGER.warning(
                "The file already exists. Use the -u or --update flag to overwrite the file. "
                "Or set the overwrite flag to True."
            )
            return 0
        # Write the slurm script as it does not exist
        with open(full_path, "w", encoding="utf-8") as f:
            f.write("\n".join(script_string))
        LOGGER.info("SLURM script generated at %s", full_path)
        return 0


    def format_slurm_args(self) -> dict[str, Any]:
        """Format the SLURM arguments into a dictionary that can be used to generate the SLURM script.

        Args:
            self: The instance of the class.

        Returns:
            A dictionary containing the SLURM arguments.
        """
        sbatch_args: dict[str, Any] = {}
        exclude_args: list[str] = [
            "batch_script_name",
            "batch_script_path",
            "initialisation_commands",
            "execution_commands",
            "verbose",
            "update",
        ]
        manually_handled_args: list[str] = [
            "slurm_verbose",  # This needs to be handled separately as its sbatch argument is --verbose
            "wait_all_nodes",  # This needs to be handled separately as its value is 0 or 1 not True or False
            "time",  # This needs to be handled separately as it needs to be converted from minutes
            "begin",  # This needs to be handled separately as it needs to be converted from minutes or a specific time
        ]
        for key, value in vars(self).items():
            if (
                (key not in exclude_args and key not in manually_handled_args)
                and value is not None
                and value
            ):
                sbatch_args[f"--{key.replace('_', '-')}"] = value
        if self.slurm_verbose:
            sbatch_args["--verbose"] = True
        if self.wait_all_nodes:
            sbatch_args["--wait-all-nodes"] = 1
        if self.begin is not None and re.match(r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}", self.begin):  # fmt: off
            sbatch_args["--begin"] = self.begin
        elif self.begin is not None and re.match(r"\d+", self.begin):
            sbatch_args["--begin"] = f"now+{self.begin}minutes"
        if self.time is not None:  # fmt: on
            number_of_days = self.time // 1440
            number_of_hours = self.time % 1440 // 60
            number_of_minutes = self.time % 60
            sbatch_args["--time"] = (
                f"{number_of_days}-{number_of_hours:02}:{number_of_minutes:02}:00"
            )
        LOGGER.debug("Formatted SLURM arguments: %s", sbatch_args)
        LOGGER.info("SLURM arguments formatted successfully.")
        return sbatch_args


def _parse_args(argv: list[str]) -> argparse.Namespace:
    """This function parses the arguments passed to the script and returns them as a namespace object.

    Args:
        # Slurm script arguments
        --batch-script-name: Name of the batch script.
        --batch-script-path: Path to the directory where the batch script will be saved.
        --initialisation-commands: Commands to run before the main program.
        --execution-commands: Commands to run the main program.
        --job-name: Name of the job.
        --partition: Partition you wish to use.
        --ntasks: Number of tasks to run.
        --cpus-per-task: Number of CPU threads used by your job.
        --mem-per-cpu: RAM in MB needed per thread.
        --mem: Total memory in MB for each node.
        --exclusive: Request exclusive use of the node.
        --time: Job time limit in minutes.
        --mail-type: Events to send email on.
        --mail-user: Email address to send job-related email to.
        --output: The path for standard out from your job.
        --error: The path for standard error from your job.
        --input: The path to a file to be used as standard input for the job.
        --gres: Request resources (e.g. GPUs) with the format 'gpu:<number>'.
        --begin: How many minutes in the future to start the job or a specific time in the format 'YYYY-MM-DDTHH:MM:SS'.
        --chdir: Directory to change to before running the job.
        --export: List of environment variables to export to the job. {ALL|NIL|NONE|[ALL],<env-var-list>}.
        --get-user-env: Load the user's login environment variables.
        --test-only: Test the job script without submitting it.
        --wait: Wait for the job to complete before returning.
        --wait-all-nodes: Wait for all nodes to be allocated before starting the job.
        --slurm-verbose: Control the verbosity of the SLURM output.
        -v, --verbose: Increase output verbosity.
        -u, --update: Overwrite the existing batch script if it already exists.

    """
    parser = argparse.ArgumentParser(
        description="Generate SLURM scripts for running compute jobs."
    )
    parser.add_argument(
        "--batch-script-name",
        type=str,
        required=True,
        help="Name of the batch script.",
    )
    parser.add_argument(
        "--batch-script-path",
        type=str,
        required=True,
        help="Path to the directory where the batch script will be saved.",
    )
    parser.add_argument(
        "--initialisation-commands",
        type=str,
        nargs="+",
        required=True,
        help="Commands to run before the main program.",
    )
    parser.add_argument(
        "--execution-commands",
        type=str,
        nargs="+",
        required=True,
        help="Commands to run the main program.",
    )
    # The following arguments are based on the SLURM configuration for SBATCH options
    parser.add_argument(
        "--job-name",
        type=str,
        required=True,
        help="Name of the job.",
    )
    parser.add_argument(
        "--partition",
        type=str,
        required=True,
        choices=["cpu-batch", "parrot", "falcon", "gecko", "eagle"],
        help="Partition you wish to use.",
    )
    parser.add_argument(
        "--ntasks",
        type=int,
        help="Number of tasks to run.",
    )
    parser.add_argument(
        "--cpus-per-task",
        type=int,
        required=True,
        help="Number of CPU threads used by your job.",
    )
    memory_group = parser.add_mutually_exclusive_group(required=True)
    memory_group.add_argument(
        "--mem-per-cpu",
        type=int,
        help="RAM in MB needed per core.",
    )
    memory_group.add_argument(
        "--mem",
        type=int,
        help="Total memory in MB for each node.",
    )
    parser.add_argument(
        "--exclusive",
        type=str,
        choices=["user", "mcs", "topo"],
        help="Request exclusive use of the node.",
    )
    parser.add_argument(
        "--time",
        type=int,
        default=2880,
        help="Job time limit in minutes.",
    )
    parser.add_argument(
        "--mail-type",
        type=str,
        nargs="+",
        choices=[
            "NONE",
            "BEGIN",
            "END",
            "FAIL",
            "REQUEUE",
            "ALL",
            "INVALID_DEPEND",
            "STAGE_OUT",
            "TIME_LIMIT_80",
            "TIME_LIMIT_90",
            "TIME_LIMIT_95",
        ],
        help="Events to send email on.",
    )
    parser.add_argument(
        "--mail-user",
        type=str,
        help="Email address to send job-related email to.",
    )
    parser.add_argument(
        "--output",
        type=str,
        default="joboutput_%j.out",
        help="The path for standard out from your job.",
    )
    parser.add_argument(
        "--error",
        type=str,
        default="joboutput_%j.err",
        help="The path for standard error from your job.",
    )
    parser.add_argument(
        "--input",
        type=str,
        help="The path to a file to be used as standard input for the job.",
    )
    parser.add_argument(
        "--gres",
        type=str,
        help="Request resources (e.g. GPUs) with the format 'gpu:<number>'.",
    )
    parser.add_argument(
        "--begin",
        type=str,
        help="How many minutes in the future to start the job or a specific time in the format 'YYYY-MM-DDTHH:MM:SS'.",
    )
    parser.add_argument(
        "--chdir",
        type=str,
        help="Directory to change to before running the job.",
    )
    parser.add_argument(
        "--export",
        type=str,
        nargs="+",
        help="List of environment variables to export to the job. {ALL|NIL|NONE|[ALL],<env-var-list>}",
    )
    parser.add_argument(
        "--get-user-env",
        action="store_true",
        help="Load the user's login environment variables.",
    )
    parser.add_argument(
        "--test-only",
        action="store_true",
        help="Test the job script without submitting it.",
    )
    parser.add_argument(
        "--slurm-verbose",
        action="store_true",
        help="Control the verbosity of the SLURM output.",
    )
    parser.add_argument(
        "--wait",
        action="store_true",
        help="Wait for the job to complete before returning.",
    )
    parser.add_argument(
        "--wait-all-nodes",
        action="store_true",
        help="Wait for all nodes to be allocated before starting the job.",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Increase output verbosity.",
    )
    parser.add_argument(
        "-u",
        "--update",
        action="store_true",
        help="Overwrite the existing batch script if it already exists.",
    )
    args = parser.parse_args(argv)
    return args


def _main(argv: list[str]) -> int:
    """This function is the main body of the script. It will call all of the required functions to generate
    the SLURM script.

    Args:
        args: The command line arguments passed to the script.

    Returns:
        0 if the script ran successfully, 1 if an error occurred.
    """
    args: argparse.Namespace = _parse_args(argv)
    LOGGER.setLevel(logging.DEBUG if args.verbose else logging.INFO)
    slurm_script_generator = GenerateSlurmScript(**vars(args))
    print(str(slurm_script_generator))
    try:
        slurm_script_generator.validate_args()
    except AssertionError as e:
        LOGGER.error("Error validating arguments:")
        LOGGER.error(e)
        return 1
    except ValueError as e:
        LOGGER.error("Error validating arguments:")
        LOGGER.error(e)
        return 1
    formatted_slurm_args = slurm_script_generator.format_slurm_args()
    return slurm_script_generator.generate_slurm_script(formatted_slurm_args)

####################################################################################################
# Main function
####################################################################################################

if __name__ == "__main__":
    logging.basicConfig(
        format="%(asctime)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        level=logging.NOTSET,
    )

    def main(args):
        """This function is the main entry point for the script. It is responsible for calling the
        main function and handling any exceptions that are raised.
        """
        try:
            result = _main(args)
            if result:
                LOGGER.error("An error occurred. Exiting...")
            sys.exit(result)
        except KeyboardInterrupt:
            LOGGER.info("Exiting...")
            sys.exit(1)
        except Exception as e:
            LOGGER.error(e)
            sys.exit(1)

    main(args=sys.argv[1:])
