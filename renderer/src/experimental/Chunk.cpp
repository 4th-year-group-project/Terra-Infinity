/*
Our world is going to be split up into large 1024x1024 super chunks which are generated by the world
generator scripts (Python). These super chunks are then split up into 32x32 subchunks which are
loaded and unloaded by the renderer as the player moves around the world.
*/

#include <Chunk.hpp>
#include <Settings.hpp>

/*
   This method will convert the chunk coordinates which are in chunk space to world space coordinates
    using the formula:
    worldX = chunkX * 1024
    worldZ = chunkZ * 1024
*/
vector<float> Chunk::getChunkWorldCoords()
{
    vector<float> worldCoords;
    worldCoords.push_back(chunkCoords[0] * size);
    worldCoords.push_back(chunkCoords[1] * size);
    return worldCoords;
}

/*
    This method will return a vector of all the loaded subchunks within the chunk
*/
vector<shared_ptr<SubChunk>> Chunk::getLoadedSubChunks()
{
    vector<shared_ptr<SubChunk>> subChunks;
    for (auto const& x : loadedSubChunks)
    {
        subChunks.push_back(x.second);
    }
    return subChunks;
}

/*
    This method will take a world position and return the subchunk id of that position within the
    chunk. The subchunk id is a unique identifier for each subchunk within the chunk. If the position
    is not within the chunk then -1 will be returned.
*/

int Chunk::getSubChunkId(glm::vec3 position)
{
    double d_size = static_cast<double>(size);
    double d_chunkMid = d_size / 2.0;
    // Determine if the position is within the chunk on the global chunk space grid
    int chunkCoordX = floor((position.x - d_chunkMid) / d_size);
    int chunkCoordZ = floor((position.z - d_chunkMid) / d_size);
    // Compare it to the global chunk coordinates of the chunk
    if (chunkCoordX != chunkCoords[0] || chunkCoordZ != chunkCoords[1])
    {
        return -1;
    }
    // Determine the subchunk coordinates within the chunk
    int startingChunkX = (chunkCoords[0] * size) - (size /2);
    int startingChunkZ = (chunkCoords[1] * size) - (size /2);
    // The subchunk ids are 0-1023 and we start with the subchunk in the bottom left corner of the
    // chunk and move to the right and then up
    glm::vec3 localPosition = glm::vec3(position.x - startingChunkX, position.y, position.z - startingChunkZ);
    int subChunkX = floor(localPosition.x / static_cast<double>(subChunkSize));
    int subChunkZ = floor(localPosition.z / static_cast<double>(subChunkSize));
    // The x coordinate determines the column and the z coordinate determines the row if we were to
    // represent the subchunks in a 32x32 grid
    return (subChunkZ * subChunkSize) + subChunkX;
}

/*
    This method will add a subchunk to the loadedSubChunks map
*/
void Chunk::addSubChunk(int id)
{
    // First we check to see if the subchunk is already `loaded` in the loadedSubChunks map
    if (loadedSubChunks.find(id) != loadedSubChunks.end()){
        return;
    }
    // If the subchunk is not loaded then we check to see if it is in the cachedSubChunks map
    else if (cachedSubChunks.find(id) != cachedSubChunks.end()) {
        // If the subchunk is in the cachedSubChunks map then we move it to the loadedSubChunks map
        loadedSubChunks[id] = move(cachedSubChunks[id]);
        cachedSubChunks.erase(id);
    }
    else {
        // If the subchunk is not in the loadedSubChunks or cachedSubChunks map then we need to
        // generate the subchunk and add it to the loadedSubChunks map
        // We will generate the subchunk using the parent chunk's vertices
        // The subchunk will be generated based on the subchunk id

        // We convert the subchunk id back into the starting chunk local coordinate for the subchunk
        // For example the id is 343 then it is the 10th row and 23rd column of the 32x32 grid
        int bottomLeftX = (id % subChunkSize) * subChunkSize;  // The coloumn of the subchunk in the 32x32 grid
        int bottomLeftZ = (id / subChunkSize) * subChunkSize;  // The row of the subchunk in the 32x32 grid
        vector<glm::vec3> subChunkVertices;
        // We also require to account for the border vertices. Suppose we have subchunk 0,0 then
        // the bottom left corner will actually be at 1,1 within the chunk vertices and we need to
        // extract the 34x34 subchunk to account for the border vertices. This would be the same as
        // extracting 0,0 to 33,33 from the chunk vertices. Hence we do not need to modify the
        // bottomLeftX and bottomLeftZ values as we can just complete two additional iterations
        for (int i = bottomLeftZ; i < bottomLeftZ + subChunkSize + 2; i++) {
            for (int j = bottomLeftX; j < bottomLeftX + subChunkSize + 2; j++) {
                subChunkVertices.push_back(vertices[i * size + j]);
            }
        }
        // We create a new subchunk object and add it to the loadedSubChunks map
        shared_ptr<SubChunk> subChunk = make_shared<SubChunk>(
            id,
            shared_ptr<Chunk>(this),
            vector<int>{bottomLeftX / size, bottomLeftZ / size},
            subChunkVertices
        );
        // Add the subchunk to the loadedSubChunks map
        loadedSubChunks[id] = subChunk;
    }
}

float Chunk::getDistanceToChunk(glm::vec3 playerPos){
    // Get the world coordinates of the chunk
    vector<float> chunkWorldCoords = getChunkWorldCoords();
    float chunkX = chunkWorldCoords[0];
    float chunkZ = chunkWorldCoords[1];
    // Get the closest point between the playerPos and the chunk to determine the distance
    float closestX = max(chunkX, min(playerPos.x, chunkX + size));
    float closestZ = max(chunkZ, min(playerPos.z, chunkZ + size));
    return sqrt(pow(playerPos.x - closestX, 2) + pow(playerPos.z - closestZ, 2));
}

/*
    This method will take in a subchunk id (0-(size/subChunkSize)^2) and return the world
    coordinates of the subchunk for its origin (bottom left corner). The subchunk id is a unique
    identifier within the chunk for each subchunk.
*/
vector<float> Chunk::getSubChunkWorldCoords(int id){
    // Get the world coordinates of the chunk
    vector<float> chunkWorldCoords = getChunkWorldCoords();
    float chunkX = chunkWorldCoords[0];
    float chunkZ = chunkWorldCoords[1];
    // Get the subchunk coordinates within the chunk
    int bottomLeftX = (id % (size / subChunkSize)) * subChunkSize;
    int bottomLeftZ = (id / (size / subChunkSize)) * subChunkSize;
    // Get the world coordinates of the subchunk
    float subChunkX = bottomLeftX + chunkX;
    float subChunkZ = bottomLeftZ + chunkZ;
    return vector<float>{subChunkX, subChunkZ};
}

/*
    This method will use the player's position and their render distance to check which subchunks
    need to be loaded and which subchunks need to be unloaded. These subchunks will be returned as
    a vector of subchunk ids to then be loaded by the renderer. The vector that is returned will be
    (size / subChunkSize) * (size / subChunkSize) with entires -1,0,1 to determine if the subchunk
    needs to be deleted, unloaded or loaded.
*/
vector<int> Chunk::checkRenderDistance(glm::vec3 playerPos, Settings settings){
    // The render distance is the number of subchunks that the player can see in each direction
    // from their current position.
    int renderDistance = settings.getRenderDistance();
    // Check if the player is within the render distance of the chunk
    float distance = getDistanceToChunk(playerPos);
    // We have to multiply by subChunkSize to get the actual distance in world space
    if (distance > renderDistance * subChunkSize){
        // If the player is not within the render distance of the chunk then we return an empty
        // vector as no subchunks need to be loaded
        return vector<int>();
    }
    // If the player is within the render distance of the chunk then we need to determine which
    // subchunks need to be loaded and which subchunks need to be unloaded
    vector<int> subChunksToLoad = vector<int>( (size / subChunkSize) * (size / subChunkSize) );
    // Iterate through all of the subchunks within the chunk and determine their render status
    for (int i = 0; i < (size / subChunkSize) * (size / subChunkSize); i++){
        // Get the subchunk id
        int subChunkId = i;
        // Get the world coordinates of the subchunk
        vector<float> subChunkWorldCoords = getSubChunkWorldCoords(subChunkId);
        float subChunkX = subChunkWorldCoords[0];
        float subChunkZ = subChunkWorldCoords[1];
        float subChunkMidX = subChunkX + (subChunkSize / 2.0);
        float subChunkMidZ = subChunkZ + (subChunkSize / 2.0);
        // Get the distance to the subchunk
        float distanceToSubChunk = sqrt(pow(playerPos.x - subChunkMidX, 2) + pow(playerPos.z - subChunkMidZ, 2));
        if (distanceToSubChunk > 2 * renderDistance * subChunkSize){
            // The subchunk is far enough away that it should be deleted to save memory
            subChunksToLoad[i] = -1;
        } else if (distanceToSubChunk > renderDistance * subChunkSize){
            // The subchunk is far enough away that it should be unloaded so it is not rendered
            subChunksToLoad[i] = 0;
        } else {
            // The subchunk is within the render distance and should be loaded and rendered
            subChunksToLoad[i] = 1;
        }

    }
    // We are going to use the centre of the chunk as the reference point for the render distance
}

/*
    This method will be used to determine and update the the subchunks that are loaded within the
    chunk based on the player's position in the world and the render distance.
*/
void Chunk::updateLoadedSubChunks(glm::vec3 playerPos, Settings settings){
    // Get the modifications that are required
    vector<int> subChunksToLoad = checkRenderDistance(playerPos, settings);
    // Check if the vector is empty as that means nothing needs to be loaded and the loaded
    // subchunks should be empty
    if (subChunksToLoad.size() == 0){
        loadedSubChunks.clear();
        cachedSubChunks.clear();
        return;
    }
    // Iterate through the subchunks and load, unload or delete them based on the modifications
    for (int i = 0; i < subChunksToLoad.size(); i++){
        // Get the subchunk id
        int subChunkId = i;
        // Get the modification that is required
        int modification = subChunksToLoad[i];
        if (modification == -1){
            // The subchunk needs to be deleted
            deleteSubChunk(subChunkId);
        } else if (modification == 0){
            // The subchunk needs to be unloaded
            unloadSubChunk(subChunkId);
        } else if (modification == 1){
            // The subchunk needs to be loaded
            addSubChunk(subChunkId);
        }
    }
}

/*
    This method will unload a subchunk from the loadedSubChunks map and move it to the
    cachedSubChunks map so that it can be reloaded later if needed.
*/
void Chunk::unloadSubChunk(int id){
    // Check to see if the subchunk is loaded in the loadedSubChunks map
    if (loadedSubChunks.find(id) != loadedSubChunks.end()){
        // If the subchunk is loaded then we move it to the cachedSubChunks map
        cachedSubChunks[id] = move(loadedSubChunks[id]);
        loadedSubChunks.erase(id);
    }
}

void Chunk::deleteSubChunk(int id){
    // Check to see if the subchunk is loaded in the loadedSubChunks map
    if (loadedSubChunks.find(id) != loadedSubChunks.end()){
        loadedSubChunks.erase(id);
    }
    // Check to see if the subchunk is in the cachedSubChunks map
    else if (cachedSubChunks.find(id) != cachedSubChunks.end()){
        cachedSubChunks.erase(id);
    }
}


/*
    This is the class destructor which will be called when the chunk is destroyed
*/
Chunk::~Chunk()
{
    // Nothing to do here
}