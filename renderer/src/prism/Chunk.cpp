/*
Our world is going to be split up into large 1024x1024 super chunks which are generated by the world
generator scripts (Python). These super chunks are then split up into 32x32 subchunks which are
loaded and unloaded by the renderer as the player moves around the world.
*/

#include <vector>
#include <memory>
#include <cmath>
#include <omp.h>

#ifdef DEPARTMENT_BUILD
    #include "/dcs/large/efogahlewem/.local/include/glm/glm.hpp"
#else
    #include <glm/glm.hpp>
#endif

#include "Chunk.hpp"
#include "SubChunk.hpp"
#include "Settings.hpp"
#include "IRenderable.hpp"
#include "Shader.hpp"
#include "Utility.hpp"


/*
   This method will convert the chunk coordinates which are in chunk space to world space coordinates
    using the formula:
    worldX = chunkX * 1024
    worldZ = chunkZ * 1024
*/
vector<float> Chunk::getChunkWorldCoords()
{
    vector<float> worldCoords;
    worldCoords.push_back(chunkCoords[0] * (size -1));
    worldCoords.push_back(chunkCoords[1] * (size -1));
    return worldCoords;
}

/*
    This method will return a vector of all the loaded subchunks within the chunk
*/
vector<shared_ptr<SubChunk>> Chunk::getLoadedSubChunks()
{
    vector<shared_ptr<SubChunk>> subChunks;
    // Iterate through the loaded subchunks array and add the subchunks 
    // that are not nullptr
    for (auto subChunk : loadedSubChunks)
    {
        if (subChunk != nullptr)
        {
            subChunks.push_back(subChunk);
        }
    }
    return subChunks;
}

/*
    This method will take a world position and return the subchunk id of that position within the
    chunk. The subchunk id is a unique identifier for each subchunk within the chunk. If the position
    is not within the chunk then -1 will be returned.
*/
int Chunk::getSubChunkId(glm::vec3 position)
{
    double d_size = static_cast<double>(size);
    double d_chunkMid = d_size / 2.0;
    // Determine if the position is within the chunk on the global chunk space grid
    int chunkCoordX = floor((position.x - d_chunkMid) / d_size);
    int chunkCoordZ = floor((position.z - d_chunkMid) / d_size);
    // Compare it to the global chunk coordinates of the chunk
    if (chunkCoordX != chunkCoords[0] || chunkCoordZ != chunkCoords[1])
    {
        return -1;
    }
    // Determine the subchunk coordinates within the chunk
    int startingChunkX = (chunkCoords[0] * size) - (size /2);
    int startingChunkZ = (chunkCoords[1] * size) - (size /2);
    // The subchunk ids are 0-1023 and we start with the subchunk in the bottom left corner of the
    // chunk and move to the right and then up
    glm::vec3 localPosition = glm::vec3(position.x - startingChunkX, position.y, position.z - startingChunkZ);
    int subChunkX = floor(localPosition.x / static_cast<double>(subChunkSize));
    int subChunkZ = floor(localPosition.z / static_cast<double>(subChunkSize));
    // The x coordinate determines the column and the z coordinate determines the row if we were to
    // represent the subchunks in a 32x32 grid
    return (subChunkZ * subChunkSize) + subChunkX;
}

/*
    This method will add a subchunk to the loadedSubChunks map
*/
int Chunk::addSubChunk(int id, float resolution)
{
    int returnCode = 0;
    // Check if the index of id is not nullptr as this means the subchunk is not loaded
    if (loadedSubChunks[id] != nullptr){
        // Check to see if the subchunk has the correct resolution
        float currentResolution = loadedSubChunks[id]->getResolution();
        if (currentResolution != resolution)
        {
            // The subchunk has the wrong resolution so we need to delete it and reload it
            loadedSubChunks[id].reset();
            loadedSubChunks[id] = nullptr;
            returnCode = addSubChunk(id, resolution);
        }
    } else if (cachedSubChunks[id] != nullptr){
        // The subchunk is in cache but we need to check if the resolution is correct
        float currentResolution = cachedSubChunks[id]->getResolution();
        if (currentResolution != resolution){
            // The subchunk has the wrong resolution so we need to delete it and
            // reload it
            cachedSubChunks[id].reset();
            cachedSubChunks[id] = nullptr;
            returnCode = addSubChunk(id, resolution);
        } else {
            // The subchunk is in cache and has the correct resolution so we can load it
            loadedSubChunks[id] = cachedSubChunks[id];
            cachedSubChunks[id].reset();
            cachedSubChunks[id] = nullptr;
        }
    } else {
        // If the subchunk is not in the loadedSubChunks or cachedSubChunks then we need to generate
        // the subchunk, which is done in a thread safe way as the vector is a fixed length and each
        // thread will only access a unique index based on the id

        // We convert the subchunk id back into the starting chunk local coordinate for the subchunk
        // For example the id is 343 then it is the 10th row and 23rd column of the 32x32 grid
        int bottomLeftX = (id % (subChunkSize + 1)) * (subChunkSize -1);  // The coloumn of the subchunk in the 32x32 grid
        int bottomLeftZ = (id / (subChunkSize + 1)) * (subChunkSize -1);  // The row of the subchunk in the 32x32 grid
        vector<vector<float>> subChunkHeights = vector<vector<float>>(subChunkSize + 2, vector<float>(subChunkSize + 2));
       
        // We also have to account for the border vertices. Suppose we have subchunk 0,0 then
        // the bottom left corner will actually be at 1,1 within the chunk vertices and we need to
        // extract the 34x34 subchunk to account for the border vertices. This would be the same as
        // extracting 0,0 to 33,33 from the chunk vertices. Hence we do not need to modify the
        // bottomLeftX and bottomLeftZ values as we can just complete two additional iterations

        // #pragma omp parallel for
        for (int z = bottomLeftZ; z < bottomLeftZ + subChunkSize + 2; z++){
            for (int x = bottomLeftX; x < bottomLeftX + subChunkSize + 2; x++){
                subChunkHeights[z - bottomLeftZ][x - bottomLeftX] = heightmapData[z][x];
            }
        }
        // Generate the subchunk
        shared_ptr<SubChunk> subChunk = make_shared<SubChunk>(
            id,
            make_shared<Chunk>(*this),
            settings,
            resolution,
            vector<int>{bottomLeftX, bottomLeftZ},
            subChunkHeights,
            terrainShader,
            oceanShader,
            terrainTextures
        );
        loadedSubChunks[id] = subChunk;
        returnCode = 1;
    }
    return returnCode;
}

float Chunk::getDistanceToChunk(glm::vec3 playerPos){
    // Get the world coordinates of the chunk
    vector<float> chunkWorldCoords = getChunkWorldCoords();
    float chunkX = chunkWorldCoords[0];
    float chunkZ = chunkWorldCoords[1];
    // Get the closest point between the playerPos and the chunk to determine the distance
    float closestX = max(chunkX, min(playerPos.x, chunkX + size));
    float closestZ = max(chunkZ, min(playerPos.z, chunkZ + size));
    return sqrt(pow(playerPos.x - closestX, 2) + pow(playerPos.z - closestZ, 2));
}

/*
    This method will take in a subchunk id (0-(size/subChunkSize)^2) and return the world
    coordinates of the subchunk for its origin (bottom left corner). The subchunk id is a unique
    identifier within the chunk for each subchunk.
*/
vector<float> Chunk::getSubChunkWorldCoords(int id){
    // Get the world coordinates of the chunk
    vector<float> chunkWorldCoords = getChunkWorldCoords();
    float chunkX = chunkWorldCoords[0];
    float chunkZ = chunkWorldCoords[1];
    // Get the subchunk coordinates within the chunk
    int bottomLeftX = (id % (subChunkSize + 1)) * (subChunkSize -1);
    int bottomLeftZ = (id / (subChunkSize + 1)) * (subChunkSize -1);
    // Get the world coordinates of the subchunk
    float subChunkX = bottomLeftX + chunkX;
    float subChunkZ = bottomLeftZ + chunkZ;
    return vector<float>{subChunkX, subChunkZ};
}

/*
    This method will use the player's position and their render distance to check which subchunks
    need to be loaded and which subchunks need to be unloaded. These subchunks will be returned as
    a vector of subchunk ids to then be loaded by the renderer. The vector that is returned will be
    (size / subChunkSize) * (size / subChunkSize) with entires -1,0,1 to determine if the subchunk
    needs to be deleted, unloaded or loaded.
*/
vector<int> Chunk::checkRenderDistance(glm::vec3 playerPos, Settings settings){
    // The render distance is the number of subchunks that the player can see in each direction
    // from their current position.
    double start = omp_get_wtime();
    int renderDistance = settings.getRenderDistance();
    // Check if the player is within the render distance of the chunk
    float distance = getDistanceToChunk(playerPos);
    // We have to multiply by subChunkSize to get the actual distance in world space
    cout << "Distance to chunk: " << distance << " for chunk: " << chunkCoords[0] << ", " << chunkCoords[1] << endl;
    if (distance > renderDistance * subChunkSize){
        // If the player is not within the render distance of the chunk then we return an empty
        // vector as no subchunks need to be loaded
        double end = omp_get_wtime();
        cout << "Time to check render distance: " << end - start << " for chunk: " << chunkCoords[0] << ", " << chunkCoords[1] << endl;
        return vector<int>();
    }
    // If the player is within the render distance of the chunk then we need to determine which
    // subchunks need to be loaded and which subchunks need to be unloaded
    vector<int> subChunksToLoad = vector<int>( ((size -1) / (subChunkSize - 1)) * ((size -1) / (subChunkSize - 1)));
    // Iterate through all of the subchunks within the chunk and determine their render status

    #pragma omp parallel for
    for (int i = 0; i < static_cast<int>(subChunksToLoad.size()); i++){
        // Get the subchunk id
        int subChunkId = i;
        // Get the world coordinates of the subchunk
        vector<float> subChunkWorldCoords = getSubChunkWorldCoords(subChunkId);
        float subChunkX = subChunkWorldCoords[0];
        float subChunkZ = subChunkWorldCoords[1];
        float subChunkMidX = subChunkX + (subChunkSize / 2.0);
        float subChunkMidZ = subChunkZ + (subChunkSize / 2.0);
        // Get the distance to the subchunk
        float distanceToSubChunk = sqrt(pow(playerPos.x - subChunkMidX, 2) + pow(playerPos.z - subChunkMidZ, 2));
        if (distanceToSubChunk > 2 * renderDistance * subChunkSize){
            // The subchunk is far enough away that it should be deleted to save memory
            subChunksToLoad[i] = -1;
        } else if (distanceToSubChunk > renderDistance * subChunkSize){
            // The subchunk is far enough away that it should be unloaded so it is not rendered
            subChunksToLoad[i] = 0;
        } else {
            // We now need to determine the subchunk's resolution based on the distance from the
            // player to the center of the subchunk where the resolution is settings.getSubChunkResolution()
            // at the player and decays to 1 at the edge of the render distance

            // If the render distance is 16 then we will be able to see 15 subchunks in each direction
            // from the player plus the subchunk that the player is in (roughly).

            subChunksToLoad[i] = 1;
            // if (distanceToSubChunk < subChunkSize){
            //     // The subchunk is within the player's render distance and should be loaded and rendered
            //     subChunksToLoad[i] = settings.getSubChunkResolution();
            // } else if (distanceToSubChunk < subChunkSize * (renderDistance  / 8.0) * 2.0){
            //     // The subchunk is within the player's render distance and should be loaded and rendered
            //     subChunksToLoad[i] = settings.getSubChunkResolution() * 0.5;
            // // // } else if (distanceToSubChunk < sqrt(2 * pow(subChunkSize * (renderDistance  / 8.0) * 5.0, 2))){
            // // //     // The subchunk is within the player's render distance and should be loaded and rendered
            // // //     subChunksToLoad[i] = settings.getSubChunkResolution() * 0.25;
            // } else {
            //     // The subchunk is within the player's render distance and should be loaded and rendered
            //     subChunksToLoad[i] = 1;
            // }
        }

    }
    double end = omp_get_wtime();
    cout << "Time to check render distance: " << end - start << " for chunk: " << chunkCoords[0] << ", " << chunkCoords[1] << endl;
    // We are going to use the centre of the chunk as the reference point for the render distance
    return subChunksToLoad;
}

/*
    This method will be used to determine and update the the subchunks that are loaded within the
    chunk based on the player's position in the world and the render distance.
*/
void Chunk::updateLoadedSubChunks(glm::vec3 playerPos, Settings settings){
    double start = omp_get_wtime();
    // Get the modifications that are required
    // We need to shift the playerPos by the inverse of the mid point of the chunk to get the
    // position relative to the rendered world coordinates
    playerPos.x += (size / 2.0);
    playerPos.z += (size / 2.0);
    vector<int> subChunksToLoad = checkRenderDistance(playerPos, settings);
    // Check if the vector is empty as that means nothing needs to be loaded and the loaded
    // subchunks should be empty
    cout << "Number of subchunks to load: " << subChunksToLoad.size() << endl;
    if (subChunksToLoad.size() == 0){
        cout << "Clearing all subchunks for chunk: " << chunkCoords[0] << ", " << chunkCoords[1] << endl;
        cout << "Number of loaded subchunks: " << loadedSubChunks.size() << ", Number of cached subchunks: " << cachedSubChunks.size() << endl;
        double clearStart = omp_get_wtime();
        loadedSubChunks.clear();
        double clearEnd = omp_get_wtime();
        cout << "Time to clear loaded subchunks: " << clearEnd - clearStart << " for chunk: " << chunkCoords[0] << ", " << chunkCoords[1] << endl;
        clearStart = omp_get_wtime();
        cachedSubChunks.clear();
        clearEnd = omp_get_wtime();
        cout << "Time to clear cached subchunks: " << clearEnd - clearStart << " for chunk: " << chunkCoords[0] << ", " << chunkCoords[1] << endl;
        double end = omp_get_wtime();
        cout << "Time to update subchunks: " << end - start << " for chunk: " << chunkCoords[0] << ", " << chunkCoords[1] << endl;
        return;
    }
    // Iterate through the subchunks and load, unload or delete them based on the modifications
    // that are required
    #pragma omp parallel for
    for (int i = 0; i < static_cast<int>(subChunksToLoad.size()); i++){
        // Get the subchunk id
        int subChunkId = i;
        // Get the modification that is required
        int modification = subChunksToLoad[i];
        if (modification == -1){
            // The subchunk needs to be deleted
            deleteSubChunk(subChunkId);
        } else if (modification == 0){
            // The subchunk needs to be unloaded
            unloadSubChunk(subChunkId);
        } else {
            // We need to create the subchunk with the new resolution
            addSubChunk(subChunkId, modification);
        }
    }
    double end = omp_get_wtime();
    cout << "Time to update subchunks: " << end - start << " for chunk: " << chunkCoords[0] << ", " << chunkCoords[1] << endl;
    // Wait for all the threads to finish
    #pragma omp barrier
}

/*
    This method will unload a subchunk from the loadedSubChunks vector and move it to the
    cachedSubChunks map so that it can be reloaded later if needed.
*/
void Chunk::unloadSubChunk(int id){
    // Check to see if index id of the loadedSubChunks vector is not nullpointer
    if (loadedSubChunks[id] != nullptr){
        // Move the subchunk to the cachedSubChunks map
        cachedSubChunks[id] = loadedSubChunks[id];
        loadedSubChunks[id].reset();
        loadedSubChunks[id] = nullptr;
    }
}

/**
 * This method will delete a subchunk from the cachedSubChunks vector and remove it from memory.
 * Th
 */
void Chunk::deleteSubChunk(int id){
    // Check to see if the subchunk is somehow still in the loadedSubChunks vector
    if (loadedSubChunks[id] != nullptr){
        loadedSubChunks[id].reset();
        loadedSubChunks[id] = nullptr;
    }
    // Check to see if the subchunk is in the cachedSubChunks vector
    if (cachedSubChunks[id] != nullptr){
        cachedSubChunks[id].reset();
        cachedSubChunks[id] = nullptr;
    }
    // These two checks should ensure that the subchunk is removed from memory and ensure that the
    // dynamic memory is freed as only these two vectors hold references to the subchunk
}


void Chunk::loadAllSubChunks(){
    // Iterate through all of the subchunks and load them

    // #pragma omp parallel for
    for (int i = 0; i < ((size - 1) / (subChunkSize - 1)) * ((size - 1) / (subChunkSize - 1)); i++){
        addSubChunk(i, settings->getSubChunkResolution());
    }
}

/*
    This is the class destructor which will be called when the chunk is destroyed
*/
Chunk::~Chunk()
{
    double start = omp_get_wtime();
    // Ensure that all of the subchunks are deleted
    for (int i = 0; i <  static_cast<int>(loadedSubChunks.size()); i++){
        if (loadedSubChunks[i] != nullptr){
            loadedSubChunks[i].reset();
            loadedSubChunks[i] = nullptr;
        }
        if (cachedSubChunks[i] != nullptr){
            cachedSubChunks[i].reset();
            cachedSubChunks[i] = nullptr;
        }
    }
    settings.reset();
    terrainShader.reset();
    oceanShader.reset();
    terrainTextures.clear();
    heightmapData.clear();
    double end = omp_get_wtime();
    cout << "Destructor time to delete chunk: " << end - start << " for chunk: " << chunkCoords[0] << ", " << chunkCoords[1] << endl;
}

void Chunk::render(
    glm::mat4 view,
    glm::mat4 projection,
    vector<shared_ptr<Light>> lights,
    glm::vec3 viewPos
)
{
    // Render all of the loaded subchunks
    for (auto const& x : loadedSubChunks)
    {
        if (x != nullptr)
        {
            x->render(view, projection, lights, viewPos);
        }
    }
}

void Chunk::setupData()
{
    // Do nothing
    // // Setup the terrain object
    // terrain->setupData();
}

void Chunk::updateData()
{
    // Do nothing
    // // Update the terrain object
    // terrain->updateData();
}